<#
Prerequisites / Notes
----------------------
- Run this script from a PowerShell (pwsh) session on Windows or macOS/Linux where PowerShell is available.
- This script expects two *text* managed heap reports produced by the repository's
  `collect-gcdump.ps1 -Report` helper (see `./scripts/collect-gcdump.ps1`).
- The reports must be the human-readable text output generated by that script; this
  parser looks for the report lines that contain "<count> <instances> <TypeName>".
- Example usage (positional args):
    pwsh -NoProfile -ExecutionPolicy Bypass -File .\scripts\diff-gcdump.ps1 "C:\path\to\before.txt" "C:\path\to\after.txt"
- Example usage (named params):
    pwsh -NoProfile -ExecutionPolicy Bypass -File .\scripts\diff-gcdump.ps1 -Before "before.txt" -After "after.txt"
- If PowerShell blocks script execution, use `-ExecutionPolicy Bypass` as shown above.
- The script prints a concise delta summary; it is not a full binary gcdump comparer.
#>
param(
  [Parameter(Mandatory=$true)][string]$Before,
  [Parameter(Mandatory=$true)][string]$After
)

function Parse-Report([string]$path) {
  $map = @{}
  foreach ($line in Get-Content -LiteralPath $path) {
    if ($line -match '^\s*([0-9,]+)\s+([0-9,]+)\s+(.+?)\s*(\[Module\(0x[0-9a-f]+\)\])?\s*$') {
      $bytes = [int64]($matches[1] -replace ',','')
      $count = [int64]($matches[2] -replace ',','')
      $type  = $matches[3].Trim()

      # Normalize the type name so callers don't need to include the report's
      # threshold suffix (e.g. "(Bytes > 1K)") in lookup keys.
      $type = ($type -replace '\s+\(Bytes\s*>\s*[^\)]+\)\s*$', '').Trim()

      # Some reports can emit the same normalized type more than once.
      if ($map.ContainsKey($type)) {
        $map[$type].Bytes += $bytes
        $map[$type].Count += $count
      } else {
        $map[$type] = @{ Bytes=$bytes; Count=$count }
      }
    }
  }
  return $map
}

$b = Parse-Report $Before
$a = Parse-Report $After
$allTypes = @($b.Keys + $a.Keys) | Sort-Object -Unique

function Get-Count($m, $t) { if ($m.ContainsKey($t)) { [int64]$m[$t].Count } else { 0 } }
function Get-Bytes($m, $t) { if ($m.ContainsKey($t)) { [int64]$m[$t].Bytes } else { 0 } }

Write-Output ("BEFORE parsed types: {0}" -f $b.Count)
Write-Output ("AFTER  parsed types: {0}" -f $a.Count)

$tv = $allTypes | Where-Object { $_ -match 'TemplateViewCache' }
Write-Output ("TemplateViewCache types found: {0}" -f $tv.Count)
if ($tv.Count -gt 0) {
  $tv | Select-Object -First 50 | ForEach-Object {
    $t = $_
    Write-Output ("  {0} : {1} -> {2}" -f $t, (Get-Count $b $t), (Get-Count $a $t))
  }
}

if (-not $dvmDeltas) {
  Write-Output "  (no deltas)"
} else {
  $dvmDeltas |
    Sort-Object -Property @(
      @{ Expression = 'DeltaCount'; Descending = $true },
      @{ Expression = 'DeltaBytes'; Descending = $true }
    ) |
    Select-Object -First 50 | ForEach-Object {
    Write-Output ("  Δ{0}  {1}  ({2} -> {3})  bytes {4} -> {5} (Δ{6})" -f $_.DeltaCount, $_.Type, $_.BeforeCount, $_.AfterCount, $_.BeforeBytes, $_.AfterBytes, $_.DeltaBytes)
  }
}

$focus = @(
  'System.Char[]',
  'System.Object[]',
  'System.Collections.Generic.HashSet.Entry<System.String>[]',
  'Microsoft.Maui.Controls.AppThemeBinding.AppThemeProxy',
  'System.Collections.Generic.Dictionary.Entry<Microsoft.Maui.Controls.BindableProperty,Microsoft.Maui.Controls.BindableObject.BindablePropertyContext>[]',
  'Syncfusion.Maui.ListView.ListViewItem',
  'Syncfusion.Maui.ListView.VisualContainer',
  'Syncfusion.Maui.ListView.ListViewHeaderItem',
  'Syncfusion.Maui.ListView.ListViewFooterItem'
)

Write-Output ""
Write-Output "Focused deltas:"
foreach ($t in $focus) {
  $bc = Get-Count $b $t; $ac = Get-Count $a $t
  $bb = Get-Bytes $b $t; $ab = Get-Bytes $a $t
  Write-Output ("{0} : {1} -> {2} (Δ{3})  bytes {4} -> {5} (Δ{6})" -f $t,$bc,$ac,($ac-$bc),$bb,$ab,($ab-$bb))
}

$deltaRows = foreach ($t in $allTypes) {
  $bc = Get-Count $b $t; $ac = Get-Count $a $t
  $dc = $ac - $bc
  if ($dc -ne 0) { [pscustomobject]@{ Type=$t; DeltaCount=$dc; Before=$bc; After=$ac } }
}

Write-Output ""
Write-Output "Top +Count deltas:"
$deltaRows | Sort-Object DeltaCount -Descending | Select-Object -First 20 | ForEach-Object {
  Write-Output ("Δ{0}  {1}  ({2} -> {3})" -f $_.DeltaCount, $_.Type, $_.Before, $_.After)
}

Write-Output ""
Write-Output "Top -Count deltas:"
$deltaRows | Sort-Object DeltaCount | Select-Object -First 20 | ForEach-Object {
  Write-Output ("Δ{0}  {1}  ({2} -> {3})" -f $_.DeltaCount, $_.Type, $_.Before, $_.After)
}
